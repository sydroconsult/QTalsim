# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QTalsim
                                 A QGIS plugin
 This Plugin creates Hydrologic Response Units (HRUs), that can be used as input data for Talsim.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-10-12
        git sha              : $Format:%H$
        copyright            : (C) 2023 by SYDRO Consult GmbH
        email                : l.treitler@sydro.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon, QCursor, QMovie
from qgis.PyQt.QtWidgets import QAction, QTableWidgetItem, QComboBox, QFileDialog, QLabel, QInputDialog
from qgis.PyQt.QtCore import QVariant
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .qtalsim_dialog import QTalsimDialog
import os.path
from qgis.core import QgsProject, QgsField, QgsVectorLayer, QgsFeature, QgsGeometry, QgsSpatialIndex, Qgis, QgsMessageLog, QgsApplication, QgsProcessingFeedback, QgsVectorFileWriter, QgsProcessingFeatureSourceDefinition
from qgis.analysis import QgsGeometrySnapper
import processing
import pandas as pd

class QTalsim:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QTalsim_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&QTalsim')
        
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.unique_values_landuse = set()
        self.ezgLayer = None
        self.clippingEZG = None
        self.soilLayer = None
        self.soilFieldNames = []
        self.soilLayerIntermediate = None
        self.landuseLayer = None
        self.landuseFields = []
        self.landuseField = None
        self.dfLanduseTalsim = None
        self.selected_landuse_parameters = None
        self.delimiter = ','
        self.finalLayer = None
        self.parameterFieldsLanduse = None

        #Field Names
        self.slopeField = None #Changed by user
        self.slopeFieldName = 'slope'
        self.IDSoil = "ID_Soil" #must be the same name as in soilParameter.csv
        self.nameSoil = 'NameSoil'
        self.fieldNameAreaEFL = "PercentageShare"
        self.fieldLanduseID = 'ID_LNZ'
        
        self.hruSoilTypeId = 'SoilTypeId'
        self.hruLandUseId = 'LandUseId'
        self.soilTypeThickness = 'LayerThickness1'
        self.subBasinUI = 'SubBasinId'

        #Output
        self.finalLayer = None
        self.eflLayer = None 
        self.landuseFinal = None
        self.soilTextureFinal = None
        self.soilTypeFinal = None
        self.outputFolder = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('QTalsim', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/qtalsim/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'QTalsim'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&QTalsim'),
                action)
            self.iface.removeToolBarIcon(action)


    class CustomFeedback(QgsProcessingFeedback):
        def __init__(self, log_function):
            super().__init__()
            self.log_function = log_function

        def setProgress(self, progress):
            pass
            #self.log_function(f"Progress: {progress}%", Qgis.Info)

        def pushInfo(self, info):
            self.log_function(f"Info: {info}", Qgis.Info)
        
        def pushWarning(self, warning):
            self.log_function(f"Warning: {warning}", Qgis.Warning)
        
        def reportError(self, error, fatalError=False):
            level = Qgis.Critical if fatalError else Qgis.Warning
            self.log_function(f"Error: {error}", level)

    def log_to_qtalsim_tab(self, message, level):
        '''
            Logging to a QTalsim tab in the current Qgis Project
        '''
        try:
            QgsMessageLog.logMessage(message, 'QTalsim', level)
        except Exception as e:
            pass

    def checkOverlappingFeatures(self, layer):
        '''
            Checks for overlapping features in an input layer.
        '''
        checked_ids = set()
        index = QgsSpatialIndex()
        for feature in layer.getFeatures():
            index.addFeature(feature) #spatial index for faster processing

        overlapping_features = []
        for feature in layer.getFeatures():
            candidate_ids = index.intersects(feature.geometry().boundingBox())
            for fid in candidate_ids:
                if fid == feature.id() or fid in checked_ids:
                    continue
                other_feature = layer.getFeature(fid)
                if feature.geometry().overlaps(other_feature.geometry()):
                    overlapping_features.append((feature.id(), other_feature.id()))
                elif feature.geometry().contains(other_feature.geometry()):
                    overlapping_features.append((feature.id(), other_feature.id()))
                elif feature.geometry().within(other_feature.geometry()):
                    overlapping_features.append((feature.id(), other_feature.id()))

        if len(overlapping_features) >= 1:
            self.log_to_qtalsim_tab(f"The following features overlap: {overlapping_features}", level=Qgis.Info)
            layer.setName("Layer with overlapping features")
            QgsProject.instance().addMapLayer(layer)
        else:
            self.log_to_qtalsim_tab(f"No overlapping polygons were found.",level=Qgis.Info)
        
    def editOverlappingFeatures(self, layer):
        '''
            Deletes overlapping features of input layer.
        '''
        snapper = QgsGeometrySnapper(layer)
        checked_ids = set()
        layer.startEditing()
        index = QgsSpatialIndex()
        for feature in layer.getFeatures():
            index.addFeature(feature) #spatial index for faster processing
        changes_made = False #needed as some overlapping features still existed after one run --> run the function multiple times, until nothing is changed
        QgsProject.instance().addMapLayer(layer)
        #Overlapping Logic
        for feature in layer.getFeatures(): #Looping over all features in input layer
            candidate_ids = index.intersects(feature.geometry().boundingBox()) #Possibly overlapping candidates of feature
            for fid in candidate_ids: #loop over possibly overlapping features
                if fid == feature.id() or fid in checked_ids:
                    continue #if the feature itself the overlapping feature or the candidate was already visited --> continue to next candidat
                other_feature = layer.getFeature(fid) #get the feature id of the possibly overlapping feature
                if feature.geometry().overlaps(other_feature.geometry()) or feature.geometry().contains(other_feature.geometry()) or feature.geometry().within(other_feature.geometry()):
                    #1st possibility: Feature contains the other_feature
                    if feature.geometry().contains(other_feature.geometry()):

                        #Calculate the difference between feature and other_feature and create new geom for the feature (that contains other_feature)
                        new_geom = feature.geometry().difference(other_feature.geometry())
                        snapped_geometry = snapper.snapGeometry(new_geom,snapTolerance=0.01) #snap the new_geom to the nearest points (necessary to delete slight gaps/overlaps)
                        index.deleteFeature(feature)
                        layer.changeGeometry(feature.id(), snapped_geometry)
                        index.addFeature(layer.getFeature(feature.id()))
                        changes_made = True
                        if feature.geometry().contains(other_feature.geometry()): #if feature still contains other_feature
                            buffered_geometry = other_feature.geometry().buffer(0.0001, 5) #very small buffer
                            new_geom = feature.geometry().difference(buffered_geometry)
                            snapped_geometry = snapper.snapGeometry(new_geom,snapTolerance=0.01) #snapping the feature to the nearest feature
                            index.deleteFeature(feature)
                            layer.changeGeometry(feature.id(), snapped_geometry)
                            index.addFeature(layer.getFeature(feature.id()))
                    #2nd possibility: Feature is within other_feature
                    elif feature.geometry().within(other_feature.geometry()):
                        #Calculate the difference between feature and other_feature and create new geom for the feature (that contains other_feature)
                        new_geom = other_feature.geometry().difference(feature.geometry())
                        snapped_geometry = snapper.snapGeometry(new_geom,snapTolerance=0.01) #snap the new_geom to the nearest points (necessary to delete slight gaps/overlaps)
                        index.deleteFeature(other_feature)
                        layer.changeGeometry(other_feature.id(), snapped_geometry)
                        index.addFeature(layer.getFeature(other_feature.id()))
                        changes_made = True
                        if feature.geometry().within(other_feature.geometry()): #if feature still contains other_feature
                            buffered_geometry = feature.geometry().buffer(0.0001, 5) #very small buffer
                            new_geom = other_feature.geometry().difference(buffered_geometry)
                            snapped_geometry = snapper.snapGeometry(new_geom,snapTolerance=0.01) #snapping the feature to the nearest feature
                            index.deleteFeature(other_feature)
                            layer.changeGeometry(other_feature.id(), snapped_geometry)
                            index.addFeature(layer.getFeature(other_feature.id()))
                    #3rd possibility: Feature is larger than other_feature  
                    elif feature.geometry().area() >= other_feature.geometry().area():
                        new_geom = feature.geometry().difference(other_feature.geometry())
                        snapped_geometry = snapper.snapGeometry(new_geom,snapTolerance=0.01)
                        index.deleteFeature(feature)
                        layer.changeGeometry(feature.id(), snapped_geometry)
                        index.addFeature(layer.getFeature(feature.id()))
                        #Sometimes when using .difference, slight overlap still exists.
                        #Therefore in the next step the other feature is buffered with a very low buffer_distance
                        if feature.geometry().overlaps(other_feature.geometry()):
                            buffered_geometry = other_feature.geometry().buffer(0.0001, 5)
                            new_geom = feature.geometry().difference(buffered_geometry)
                            snapped_geometry = snapper.snapGeometry(new_geom,snapTolerance=0.01)
                            index.deleteFeature(feature)
                            layer.changeGeometry(feature.id(), snapped_geometry)
                            index.addFeature(layer.getFeature(feature.id()))              
                        changes_made = True
                    else:
                        #3rd posssibility: other_feature is larger
                        new_geom = other_feature.geometry().difference(feature.geometry())
                        snapped_geometry = snapper.snapGeometry(new_geom,snapTolerance=0.01)
                        index.deleteFeature(other_feature)
                        layer.changeGeometry(other_feature.id(), snapped_geometry)
                        index.addFeature(layer.getFeature(other_feature.id()))
                        if other_feature.geometry().overlaps(feature.geometry()):
                            buffered_geometry = feature.geometry().buffer(0.0001, 5)
                            new_geom = other_feature.geometry().difference(buffered_geometry)
                            snapped_geometry = snapper.snapGeometry(new_geom, snapTolerance=1)
                            index.deleteFeature(other_feature)
                            layer.changeGeometry(other_feature.id(), snapped_geometry)
                            index.addFeature(layer.getFeature(other_feature.id()))
                        changes_made = True
            checked_ids.add(feature.id())
        layer.commitChanges()

        #Edit invalid features
        invalid_feature_ids = []
        for feature in layer.getFeatures():
            #Check if the feature's geometry is valid
            if not feature.geometry().isGeosValid():
                #If not valid, add its ID to the list
                invalid_feature_ids.append(feature.id())
        
        if len(invalid_feature_ids) >= 1:
            layer = processing.run("native:fixgeometries", {'INPUT':layer,'METHOD':1, 'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)['OUTPUT']
        
        return layer, changes_made

    def clipLayer(self, layer, clipping_layer):
        '''
            Clips input layer with clipping_layer.
                First checks validity of input layer and then clips this layer.
        '''
        #Check Geometry
        result = processing.run("qgis:checkvalidity", {'INPUT_LAYER':layer,'METHOD':2,'IGNORE_RING_SELF_INTERSECTION':False,'VALID_OUTPUT':'TEMPORARY_OUTPUT','INVALID_OUTPUT':'TEMPORARY_OUTPUT','ERROR_OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        
        outputLayer = result['VALID_OUTPUT']
        #Clip valid geometry
        resultClipping = processing.run("native:clip", {
                'INPUT': outputLayer,
                'OVERLAY': clipping_layer,
                'OUTPUT': 'TEMPORARY_OUTPUT'
        }, feedback=self.feedback)

        resultClippingLayer = resultClipping['OUTPUT']
        
        #After clipping Problems with multipart polygons can arise
        result_singlepart = processing.run("native:multiparttosingleparts", {'INPUT': resultClippingLayer,'OUTPUT': 'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        layer = result_singlepart['OUTPUT']
        return layer
    
    def checkGaps(self, layer, extent):
        '''
        Checks for gaps
            very small gaps at the boundary of the layer are not detected.
        :param layer: layer where polygons are eliminated
        :param extent: layer (e.g. dissolved catchment area layer) that defines the boundary of layer.
        '''
        #Low, negative Buffer, to exclude gaps at the edge of the polygon when looking for gaps of the soil & landuse layers
        result_buffer = processing.run("native:buffer", {'INPUT': extent,'DISTANCE': -0.00001,  'OUTPUT': 'TEMPORARY_OUTPUT'})
        extent = result_buffer['OUTPUT']

        #Find Gaps between layer and extent
        union_geom = QgsGeometry.unaryUnion([feature.geometry() for feature in layer.getFeatures()])
        union_geom_extent = QgsGeometry.unaryUnion([feature.geometry() for feature in extent.getFeatures()])
        holes = union_geom_extent.difference(union_geom)
        
        #Find gaps within the layer 
        dissolved = processing.run("native:dissolve", {
            'INPUT': layer,
            'FIELD':[],
            'OUTPUT': 'memory:'
        },feedback=self.feedback)['OUTPUT']

        
        gaps = []
        for feature in dissolved.getFeatures():
            geom = feature.geometry()
            if geom.isMultipart():
                polygons = geom.asMultiPolygon()
            else:
                polygons = [geom.asPolygon()]
            
            for polygon in polygons:
                # Interior rings are at index 1 and onwards
                for interior_ring in polygon[1:]:
                    gaps.append(QgsGeometry.fromPolygonXY([interior_ring]))

        
        #Create Gaps Layer
        crs = layer.crs().authid()
        gapsLayer = QgsVectorLayer(f"Polygon?crs={crs}","Gaps","memory")

        dp = gapsLayer.dataProvider()
        dp.addAttributes([])
        gapsLayer.updateFields()

        for gap_geom in gaps:
            if holes.isMultipart():
                # If holes is a multipart geometry, combine with each part
                for part in holes.asGeometryCollection():
                    combined_geom = part.combine(gap_geom)
                    holes = QgsGeometry.unaryUnion([holes, combined_geom])
            else:
                # If holes is a single geometry
                holes = holes.combine(gap_geom)

        if holes.isMultipart():
            geom_parts = holes.asGeometryCollection()
        else:
            geom_parts = [holes]

        for hole_geom in geom_parts:
            feat = QgsFeature()
            feat.setGeometry(hole_geom)
            dp.addFeature(feat)
        gapsLayer.updateExtents()

        dp.addAttributes([QgsField("gapFeature", QVariant.Int)])
        gapsLayer.updateFields()
        gapsLayer.startEditing()
        # Set this new attribute for all features in gapsLayer
        for feature in gapsLayer.getFeatures():
            feature['gapFeature'] = 1  # Set identifier
            gapsLayer.updateFeature(feature)
        gapsLayer.commitChanges()

        QgsProject.instance().addMapLayer(gapsLayer)
    
    def fillGaps(self, layer, extent, mode):
        '''
        Fills Gaps
            First finds gaps between extent layer and layer and then gaps within the layer.
        :param layer: layer where polygons are eliminated
        :param extent: layer (e.g. dissolved catchment area layer) that defines the boundary of layer
        '''

        #Find Gaps between layer and extent
        union_geom = QgsGeometry.unaryUnion([feature.geometry() for feature in layer.getFeatures()])
        union_geom_extent = QgsGeometry.unaryUnion([feature.geometry() for feature in extent.getFeatures()])
        holes = union_geom_extent.difference(union_geom)
        
        #Find gaps within the layer 
        dissolved = processing.run("native:dissolve", {
            'INPUT': layer,
            'FIELD':[],
            'OUTPUT': 'memory:'
        }, feedback=self.feedback)['OUTPUT']

        
        gaps = []
        for feature in dissolved.getFeatures():
            geom = feature.geometry()
            if geom.isMultipart():
                polygons = geom.asMultiPolygon()
            else:
                polygons = [geom.asPolygon()]
            
            for polygon in polygons:
                # Interior rings are at index 1 and onwards
                for interior_ring in polygon[1:]:
                    gaps.append(QgsGeometry.fromPolygonXY([interior_ring]))

        
        #Create Gaps Layer
        crs = layer.crs().authid()
        gapsLayer = QgsVectorLayer(f"Polygon?crs={crs}","Gaps","memory")

        dp = gapsLayer.dataProvider()
        dp.addAttributes([])
        gapsLayer.updateFields()

        for gap_geom in gaps:
            if holes.isMultipart():
                # If holes is a multipart geometry, combine with each part
                for part in holes.asGeometryCollection():
                    combined_geom = part.combine(gap_geom)
                    holes = QgsGeometry.unaryUnion([holes, combined_geom])
            else:
                # If holes is a single geometry
                holes = holes.combine(gap_geom)

        if holes.isMultipart():
            geom_parts = holes.asGeometryCollection()
        else:
            geom_parts = [holes]

        for hole_geom in geom_parts:
            feat = QgsFeature()
            feat.setGeometry(hole_geom)
            dp.addFeature(feat)
        gapsLayer.updateExtents()

        # Add a new attribute field to identify features from gapsLayer
        dp.addAttributes([QgsField("gapFeature", QVariant.Int)])
        gapsLayer.updateFields()
        gapsLayer.startEditing()
        # Set this new attribute for all features in gapsLayer
        for feature in gapsLayer.getFeatures():
            feature['gapFeature'] = 1  # Set identifier
            gapsLayer.updateFeature(feature)
        gapsLayer.commitChanges()

        result_merge = processing.run("native:mergevectorlayers", {'LAYERS': [layer, gapsLayer],  'OUTPUT': 'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        merged_layer = result_merge['OUTPUT']

        for feature in merged_layer.getFeatures():
            if feature['gapFeature'] == 1:
                merged_layer.select(feature.id())

        result_eliminate = processing.run("qgis:eliminateselectedpolygons", {
            'INPUT': merged_layer,
            'MODE': mode,  
            'OUTPUT': 'TEMPORARY_OUTPUT'
        },feedback=self.feedback)
        layer_without_gaps = result_eliminate['OUTPUT']

        return layer_without_gaps
    
    def selectEZG(self):
        '''
            Loads the catchment area layer.
            Deletes overlapping features and duplicates.
            A temporary catchment area layer, which is used for clipping the soil and landuse layer, is created. 
            This temporary catchment area layer is a dissolved, non-self-overlapping layer without gaps.
        '''

        selected_layer_ezg = self.dlg.comboboxEZGLayer.currentText()
        self.ezgLayer = QgsProject.instance().mapLayersByName(selected_layer_ezg)[0]
        #self.dlg.comboboxIntersectEZGField.addItems([field.name() for field in self.ezgLayer.fields()])
        outputLayer = processing.run("native:deleteduplicategeometries", {'INPUT': self.ezgLayer ,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)['OUTPUT']
        self.ezgLayer, _ = self.editOverlappingFeatures(outputLayer)
        #Dissolve of catchment areas for better clipping performance
        result = processing.run("native:dissolve", {'INPUT': self.ezgLayer, 'FIELD':[],'SEPARATE_DISJOINT':False,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        outputLayer = result['OUTPUT']

         #delete overlapping features in the catchment area layer
        result_deleteholes = processing.run("native:deleteholes", {'INPUT':outputLayer,'MIN_AREA':0,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        self.clippingEZG = result_deleteholes['OUTPUT'] #delete holes within the dissolved catchment area layer for clipping
        #QgsProject.instance().addMapLayer(self.clippingEZG)

        self.dlg.comboboxUICatchment.clear() #clear combobox EZG from previous runs
        self.dlg.comboboxUICatchment.addItems([field.name() for field in self.ezgLayer.fields()])

        self.dlg.comboboxSlopeField.clear()
        self.dlg.comboboxSlopeField.addItems([field.name() for field in self.ezgLayer.fields()])
        self.ezgLayer.setName("CatchmentArea")
        QgsProject.instance().addMapLayer(self.ezgLayer)
        self.log_to_qtalsim_tab(f"Successfully selected and clipped catchment area layer: {self.ezgLayer.name()}.", Qgis.Info) 

    def selectSoil(self):
        '''
            Selects and clips the soil layer and removes duplicate geometries.
                Also fills the soil mapping table. 
        '''
        self.log_to_qtalsim_tab(f"Starting the clipping process of the Soil Layer.", Qgis.Info) 
        #Select Layer
        selected_layer_soil = self.dlg.comboboxSoilLayer.currentText()
        self.soilLayer = QgsProject.instance().mapLayersByName(selected_layer_soil)[0]

        #Clip Layer
        outputLayer = self.clipLayer(self.soilLayer, self.clippingEZG)
        outputLayer = processing.run("native:deleteduplicategeometries", {'INPUT': outputLayer ,'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        self.soilLayer = outputLayer

        self.fillSoilTable()
        self.soilLayer.setName("SoilLayer")
        QgsProject.instance().addMapLayer(self.soilLayer)
        self.log_to_qtalsim_tab(f"Successfully selected and clipped Soil Layer: {self.soilLayer.name()}.", Qgis.Info) 

    def fillSoilTable(self):
        '''
            Fills the soil mapping table with the field names of the soil layer and the Talsim parameter names.
                Is executed in function selectSoil.
        '''
        fieldsSoil = [field.name() for field in self.soilLayer.fields()]
        current_path = os.path.dirname(os.path.abspath(__file__))
        soilTalsimPath = os.path.join(current_path, "talsim parameter", "soilParameter.csv")
        self.dfsoilParametersTalsim = pd.read_csv(soilTalsimPath,delimiter = ';')

        #Create Table
        self.dlg.tableSoilMapping.setRowCount(self.dfsoilParametersTalsim.shape[0])
        self.dlg.tableSoilMapping.setColumnCount(2)
        self.dlg.tableSoilMapping.setHorizontalHeaderLabels(['Talsim Soil Parameters', 'Soil Layer Fields'])
        
        # Set the size of the table columns
        self.dlg.tableSoilMapping.setColumnWidth(0, 300)
        self.dlg.tableSoilMapping.setColumnWidth(1, 300)

        #Get Landuse Data from csv-file
        soilTextures = self.dfsoilParametersTalsim.loc[:,'SoilTexture']
        #Fill data
        for row, data in enumerate(soilTextures):

            item = QTableWidgetItem(data) #add soil
            self.dlg.tableSoilMapping.setItem(row, 0, item)
            
            combo_box = QComboBox()
            # Add parameters as items to the combo box
            if data != self.nameSoil and data != self.IDSoil:
                combo_box.addItem('Parameter not available')

            if data == self.IDSoil:
                combo_box.addItem('Feature IDs of Soil Layer')

            combo_box.addItems([str(field) for field in fieldsSoil])
            self.dlg.tableSoilMapping.setCellWidget(row, 1, combo_box)
            #item = QTableWidgetItem(name_value)
            #self.dlg.tableLanduseMapping.setItem(row, 1, item)
        self.dlg.onCreateSoilLayer.setVisible(True)

    def confirmSoilMapping(self):
        '''
            Creates a new Soil Talsim layer, which holds all the parameters of Table soilmapping. 
        '''
        self.log_to_qtalsim_tab(f"Starting Soil Mapping.", Qgis.Info) 
        #Create Layer
        self.soilLayerIntermediate = QgsVectorLayer(f"Polygon?crs={self.soilLayer.crs().authid()}", "SoilLayer", "memory")

        #Get features of input soil layer
        feats = [feat for feat in self.soilLayer.getFeatures()] 

        #Populate new Soil Talsim Layers with features of input soil layer
        mem_layer_data = self.soilLayerIntermediate.dataProvider()
        attr = self.soilLayer.dataProvider().fields().toList()
        mem_layer_data.addAttributes(attr)
        self.soilLayerIntermediate.updateFields()
        mem_layer_data.addFeatures(feats)

        #Get the mapping of the talsim soil parameter and the corresponding parameters defined by the user
        textureTypes = self.dfsoilParametersTalsim.loc[:,'TextureType'] #Get the texture types
        value_mapping = {}
        new_fields = []
        fields_wrong_datatype = [] #store those fields that have a wrong datatype 
        for row in range(self.dlg.tableSoilMapping.rowCount()): #Loop over all entries of the Soil Mpaping Table
            old_field = self.dlg.tableSoilMapping.cellWidget(row, 1).currentText() #Current Text of Combo-Box specified by user
            new_field = self.dlg.tableSoilMapping.item(row, 0).text() #Get talsim parameter
            value_mapping[old_field] = new_field
            if textureTypes[row] == 'string':
                type = QVariant.String
            elif textureTypes[row] == 'float':
                type = QVariant.Double
            elif textureTypes[row] == 'int':
                type = QVariant.Type.Int
            else:
                type = QVariant.String
            new_fields.append(QgsField(str(new_field), type)) #Store talsim parameters in a variable
            self.soilFieldNames.append(new_field)
            if self.soilLayerIntermediate.fields().indexOf(old_field) != -1:
                type_old = self.soilLayerIntermediate.fields().field(old_field).type()
                if type_old != type:
                    self.log_to_qtalsim_tab(f'The parameter {old_field} has type {QVariant.typeToName(type_old)}, when it should have type {QVariant.typeToName(type)}.', Qgis.Warning)
                    fields_wrong_datatype.append(old_field)
                #if new_field == 'Name' and old_field is 'Parameter not available':
                   
        self.soilLayerIntermediate.dataProvider().addAttributes(new_fields) #create new fields with the talsim parameters
        self.soilLayerIntermediate.updateFields()
        
        #Populate soil parameter fields in soil layer
        self.soilLayerIntermediate.startEditing()
        try:
            for feature in self.soilLayerIntermediate.getFeatures():
                for old_field, new_field in value_mapping.items():
                    if old_field == 'Parameter not available':
                        feature[new_field] = None 
                    elif old_field == 'Feature IDs of Soil Layer':
                        feature[new_field] = int(feature.id())
                    else:
                        new_field_type = self.soilLayerIntermediate.fields().field(new_field).type()
                        if isinstance(feature[old_field], str) and new_field_type == QVariant.Int:
                            try:
                                feature[new_field] = int(feature[old_field])
                            except:
                                feature[new_field] = None
                        elif isinstance(feature[old_field], str) and new_field_type == QVariant.Double:
                            try:
                                feature[new_field] = float(feature[old_field])
                            except:
                                feature[new_field] = None
                        else:
                            feature[new_field] = feature[old_field]                              
                try:
                    self.soilLayerIntermediate.updateFeature(feature)
                except Exception as e:
                    self.soilLayerIntermediate.updateFeature(feature)
                    self.log_to_qtalsim_tab(e, level=Qgis.Warning)

        except Exception as e:
            error_message = f"An error occurred: {str(e)}"
            self.log_to_qtalsim_tab(error_message, level=Qgis.Critical)
        try:
            self.soilLayerIntermediate.commitChanges()
        except Exception as e:
            self.log_to_qtalsim_tab(e, )
        self.soilLayerIntermediate.dataProvider().reloadData()

        #populate soilTypesDelete
        self.dlg.soilTypesDelete.clear()

        # Get the fields of the selected layer
        self.soilFields = self.soilLayerIntermediate.fields()

        field_index = self.soilFields.indexFromName(self.nameSoil)
        # Check if the field index is valid
        if field_index >= 0:
            field_values = [feature.attributes()[field_index] for feature in self.soilLayerIntermediate.getFeatures()]
            self.unique_soiltypes = set(field_values) #Fill data
            self.dlg.soilTypesDelete.addItems([str(soiltype) for soiltype in self.unique_soiltypes]) 
        if self.soilLayer:
            QgsProject.instance().removeMapLayer(self.soilLayer)
        
        self.log_to_qtalsim_tab(f"Finished soil parameter mapping. Inspect results in this layer: {self.soilLayerIntermediate.name()}.", Qgis.Info) 
        QgsProject.instance().addMapLayer(self.soilLayerIntermediate)

    def checkOverlappingSoil(self):
        '''
            Checks for overlapping soilFeatures.
        '''
        self.checkOverlappingFeatures(self.soilLayerIntermediate)

    def deleteOverlappingSoilFeatures(self):
        '''
            Deletes Overlapping Soil Features.
                Function 'editOverlappingFeatures' is run multiple times (as long as overlapping features exist) to remove all overlapping features.
        '''
        changes_made = True
        max_iteration = 5
        iteration = 0
        while changes_made and iteration < max_iteration:
            self.soilLayerIntermediate, changes_made = self.editOverlappingFeatures(self.soilLayerIntermediate)
            iteration += 1
        
        if not changes_made and iteration == 1:
            self.log_to_qtalsim_tab("No overlapping features were found.", level=Qgis.Info)
        else:
            self.log_to_qtalsim_tab("No further overlaps detected.", level=Qgis.Info)

        self.soilLayerIntermediate.setName("SoilLayerEdited")
        QgsProject.instance().addMapLayer(self.soilLayerIntermediate)

    def deleteSoilTypes(self):
        '''
            Deletes unwanted soiltypes, selected by the user.
        '''

        self.soilLayerIntermediate.startEditing()
        ids_to_delete = []
        self.soiltypes_to_delete = [item.text() for item in self.dlg.soilTypesDelete.selectedItems()] 
        field_index = self.soilFields.indexFromName(self.nameSoil)
        
        for feature in self.soilLayerIntermediate.getFeatures(): 
            #wenn Feature von self.soiltypeField ist makiert in soilTypesDelete --> löschen
            if str(feature.attributes()[field_index]) in self.soiltypes_to_delete:
                ids_to_delete.append(feature.id())

        for fid in ids_to_delete:
            self.soilLayerIntermediate.deleteFeature(fid)
        self.log_to_qtalsim_tab(f"Number of Features deleted: {len(ids_to_delete)}", Qgis.Info)
        self.soilLayerIntermediate.commitChanges()

        self.soilLayerIntermediate.setName("SoilLayerEdited")
        QgsProject.instance().addMapLayer(self.soilLayerIntermediate)

    def checkGapsSoil(self):
        '''
            Checks for gaps in soil layer.
        '''
        self.checkGaps(self.soilLayerIntermediate, self.clippingEZG)

    def fillGapsSoil(self):
        '''
            Fills gaps of soil layer according to mode chosen by user.
        '''
        mode = 0 
        if self.dlg.comboboxModeEliminateSoil.currentText() == 'Smallest Area':
            mode = 1
        elif self.dlg.comboboxModeEliminateSoil.currentText() == 'Largest Common Boundary':
            mode = 2
        elif self.dlg.comboboxModeEliminateSoil.currentText() == 'Largest Area':
            mode = 0
        
        layerWithoutGaps = self.fillGaps(self.soilLayerIntermediate, self.clippingEZG, mode)
        if self.soilLayerIntermediate:
            QgsProject.instance().removeMapLayer(self.soilLayerIntermediate)
        self.soilLayerIntermediate = layerWithoutGaps
        self.soilLayerIntermediate.setName("SoilLayerEdited")
        self.log_to_qtalsim_tab(f"Filled gaps of layer {self.soilLayerIntermediate.name()}.", Qgis.Info) 
        QgsProject.instance().addMapLayer(self.soilLayerIntermediate)
        
    def createSoilLayer(self):
        '''
            Creates Talsim Soil Layer 
                Dissolves by Talsim parameters and deletes fields that are not needed for Talsim. 
        '''
        #Dissolve the layer using the talsim soil parameters
        resultDissolve = processing.run("native:dissolve", {'INPUT':self.soilLayerIntermediate,'FIELD': self.soilFieldNames,'SEPARATE_DISJOINT':True,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        self.soilTalsim = resultDissolve['OUTPUT']
        
        #Only keep relevant fields
        all_fields = [field.name() for field in self.soilTalsim.fields()]
        fields_to_delete_indices = [self.soilTalsim.fields().indexFromName(field)  for field in all_fields if field not in self.soilFieldNames]
        self.soilTalsim.startEditing()
        self.soilTalsim.dataProvider().deleteAttributes(fields_to_delete_indices)
        self.soilTalsim.commitChanges()
        self.soilTalsim.updateFields()
        
        if self.soilLayerIntermediate:
            QgsProject.instance().removeMapLayer(self.soilLayerIntermediate)
        self.soilTalsim.setName("Talsim Soil")
        self.log_to_qtalsim_tab(f"Created Soil Layer with Talsim Parameters: {self.soilTalsim.name()}.", Qgis.Info) 
        QgsProject.instance().addMapLayer(self.soilTalsim)  

    def selectLanduse(self):
        '''
            Clips Landuse Layer and deletes duplicate geometries. 
        '''
        self.log_to_qtalsim_tab(f"Starting the clipping process of the Landuse Layer.", Qgis.Info) 
        selected_layer_name = self.dlg.comboboxLanduseLayer.currentText()
        self.landuseLayer = QgsProject.instance().mapLayersByName(selected_layer_name)[0]
        self.dlg.comboboxLanduseFields.setVisible(True)

        #Clip Layer
        outputLayer = self.clipLayer(self.landuseLayer, self.clippingEZG)
        outputLayer = processing.run("native:deleteduplicategeometries", {'INPUT': outputLayer ,'OUTPUT':'TEMPORARY_OUTPUT'},feedback=self.feedback)['OUTPUT']
        self.landuseLayer = outputLayer

        # Get the fields of the selected layer
        self.landuseFields = self.landuseLayer.fields()

        # Populate comboboxLanduseFields with field names
        self.dlg.comboboxLanduseFields.clear()
        self.dlg.comboboxLanduseFields.addItems([field.name() for field in self.landuseFields])

        self.landuseLayer.setName("LanduseLayer")
        self.log_to_qtalsim_tab(f"Successfully selected and clipped Landuse Layer: {self.landuseLayer.name()}.", Qgis.Info) 
        QgsProject.instance().addMapLayer(self.landuseLayer)

    def openLanduseTalsimCSV(self):
        '''
            Load CSV-File containing the Talsim Landuse Names and Parameters
        '''
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly
        self.file_path = None
        try:
            self.file_path, _ = QFileDialog.getOpenFileName(self.dlg, "Open CSV File", "", "CSV Files (*.csv);;All Files (*)", options=options)
            if self.file_path:
                self.dlg.csvPath.setText(self.file_path)
        except Exception as e:
            self.log_to_qtalsim_tab(e,Qgis.Critical)

    def updateCsvDelimiter(self):
        try:
            # Load the CSV file into a pandas DataFrame
            if self.dlg.radioButtonComma.isChecked():
                self.delimiter = ','
            elif self.dlg.radioButtonSemicolon.isChecked():
                self.delimiter = ';'
            elif self.dlg.radioButtonTabulator.isChecked():
                self.delimiter = '\t'
            elif self.dlg.radioButtonSpace.isChecked():
                self.delimiter= ' '
            elif self.dlg.radioButtonOtherDel.isChecked():
                # Get the custom delimiter from the QLineEdit
                self.delimiter = self.dlg.textOther.text() 
            self.dfLanduseTalsim = pd.read_csv(self.file_path, delimiter=self.delimiter) 

            self.selected_landuse_parameters = [header for header in self.dfLanduseTalsim.columns.values]
            self.log_to_qtalsim_tab(f"Landuse Parameters: {self.selected_landuse_parameters}", Qgis.Info)
        except Exception as e:
            self.log_to_qtalsim_tab(f"Error: {e}", Qgis.Warning)

    def landuseAssigning(self):
        self.landuseField = self.dlg.comboboxLanduseFields.currentText()
        field_index = self.landuseFields.indexFromName(self.landuseField)
    
        # Check if the field index is valid
        if field_index >= 0:
            field_values = [feature.attributes()[field_index] for feature in self.landuseLayer.getFeatures()]
            self.unique_values_landuse = set(field_values)

    def fillLanduseTable(self):
        '''
            Fills the Landuse Table with data of the csv-File and Landuse Input Layer.
                The User can then assign the Landuses to Talsim Landuses.
        '''
        #Create Table
        self.dlg.tableLanduseMapping.setRowCount(len(self.unique_values_landuse))
        self.dlg.tableLanduseMapping.setColumnCount(2)
        self.dlg.tableLanduseMapping.setHorizontalHeaderLabels(['Eingabefelder', 'Talsim Fields'])
        
        # Set the size of the table columns
        self.dlg.tableLanduseMapping.setColumnWidth(0, 300)
        self.dlg.tableLanduseMapping.setColumnWidth(1, 300)

        #Get Landuse Data from csv-file
        uniqueTalsimLanduse = self.dfLanduseTalsim['Name'].unique()

        #Function to get the name of the landuse (talsim landuse csv) when in the user's input there is a field with the same name as in key-column (talsim landuse csv)
        def get_name_from_key(key):
            row = self.dfLanduseTalsim[self.dfLanduseTalsim['Name'] == key]
            if not row.empty: 
                return row.iloc[0]['Name']
            else:
                return "No matching Talsim land use found."
            
        #Fill data
        for row, data in enumerate(self.unique_values_landuse):  # Loop through all rows
            item = QTableWidgetItem(data)
            self.dlg.tableLanduseMapping.setItem(row, 0, item)
            
            combo_box = QComboBox()
    
            # Get the 'Name' value based on 'Key' or use the original data
            name_value = get_name_from_key(data)
            
            # Add the 'Name' value and original data as items to the combo box
            combo_box.addItem(str(name_value))
            combo_box.addItem('Delete Landuse')
            combo_box.addItems([str(landuse) for landuse in uniqueTalsimLanduse])
            self.dlg.tableLanduseMapping.setCellWidget(row, 1, combo_box)
            #item = QTableWidgetItem(name_value)
            #self.dlg.tableLanduseMapping.setItem(row, 1, item)
        self.dlg.onLanduseConfirm.setVisible(True)

    def confirmLanduseClassification(self):
        '''
            Creates the Talsim Landuse Layer according to the Landuse Mapping.
                The resulting layer can still have gaps and overlaps, these are removed in another step.
        '''
        self.log_to_qtalsim_tab("Start Landuse Mapping", Qgis.Info)
        self.landuseTalsim = QgsVectorLayer(f"Polygon?crs={self.landuseLayer.crs().authid()}", "Talsim Landuse", "memory")
        feats = [feat for feat in self.landuseLayer.getFeatures()]

        mem_layer_data = self.landuseTalsim.dataProvider()
        attr = self.landuseLayer.dataProvider().fields().toList()
        mem_layer_data.addAttributes(attr)
        self.landuseTalsim.updateFields()
        mem_layer_data.addFeatures(feats)

        #Add new fields
        for parameter in self.selected_landuse_parameters: #Field names Talsim parameters
            self.parameterFieldsLanduse = QgsField(parameter, QVariant.String) #add a Field with each parameter chosen
            self.landuseTalsim.dataProvider().addAttributes([self.parameterFieldsLanduse])
            self.landuseTalsim.updateFields()

        new_field = QgsField('Talsim Landuse', QVariant.String) #Talsim Landnutzung
        self.landuseTalsim.dataProvider().addAttributes([new_field])
        self.landuseTalsim.updateFields()
        
        value_mapping = {}

        # Create Value Mapping for the table
        for row in range(self.dlg.tableLanduseMapping.rowCount()):
            old_value = self.dlg.tableLanduseMapping.item(row, 0).text()
            new_value = self.dlg.tableLanduseMapping.cellWidget(row, 1).currentText()
            value_mapping[old_value] = new_value

        
        self.landuseTalsim.startEditing()
        ids_to_delete = [] 
        # Iterate through the features of the duplicate layer
        for feature in self.landuseTalsim.getFeatures():
            # Get the old value from the feature
            old_value = feature[self.landuseField]
            new_value = value_mapping.get(old_value, '')  # Lookup the corresponding new value from the value_mapping dictionary
            if new_value == 'Delete Landuse':
                ids_to_delete.append(feature.id())
                continue #next iteration
            feature['Talsim Landuse'] = new_value # Set the value for the new column
            if len(self.selected_landuse_parameters) >= 1:
                row = self.dfLanduseTalsim.loc[self.dfLanduseTalsim['Name'] == new_value] #get all entries of csv of the current landuse
                try:
                    parameter_values_dict = row[self.selected_landuse_parameters].iloc[0].to_dict()
                    for parameter in self.selected_landuse_parameters:
                        parameter_value = parameter_values_dict.get(parameter,'')
                        feature[parameter] = parameter_value
                    self.landuseTalsim.updateFeature(feature)  # Update the feature in the new Talsim landuse layer
                except Exception as e:
                    error_message = f"An error occurred: {str(e)}"
                    self.log_to_qtalsim_tab(error_message, level=Qgis.Critical) 
        
        for fid in ids_to_delete:
            self.landuseTalsim.deleteFeature(fid)
        self.landuseTalsim.commitChanges()
        
        self.landuseTalsim.setName("Talsim Landuse")
        self.log_to_qtalsim_tab(f"Finished landuse mapping. Inspect results in this layer: {self.landuseTalsim.name()}.", Qgis.Info) 
        QgsProject.instance().addMapLayer(self.landuseTalsim)
        self.dlg.onCreateLanduseLayer.setVisible(True)
    
    def checkOverlappingLanduse(self):
        self.checkOverlappingFeatures(self.landuseTalsim)

    def deleteOverlappingLanduseFeatures(self):
        '''
            Deletes the overlapping features of landuse layer. Multiple runs necessary because removing overlapping features 
            can result in more overlapping features.
        '''
        changes_made = True
        max_iteration = 5
        iteration = 0
        while changes_made and iteration < max_iteration:
            self.landuseTalsim, changes_made = self.editOverlappingFeatures(self.landuseTalsim)
            iteration += 1
        
        #QgsProject.instance().addMapLayer(outputLayer)
        if not changes_made and iteration == 1:
            self.log_to_qtalsim_tab("No overlapping features were found.", level=Qgis.Info)
        elif iteration >= max_iteration:
            self.log_to_qtalsim_tab("Maximum number of iterations reached, there may still be overlaps.", level=Qgis.Info)
        else:
            self.log_to_qtalsim_tab("No further overlaps detected.", level=Qgis.Info)

        self.landuseTalsim.setName("LanduseLayerEdited")
        QgsProject.instance().addMapLayer(self.landuseTalsim)
    
    def checkGapsLanduse(self):
        self.checkGaps(self.landuseTalsim, self.clippingEZG)

    def fillGapsLanduse(self):
        mode = 0 
        if self.dlg.comboboxModeEliminateLanduse.currentText() == 'Smallest Area':
            mode = 1
        elif self.dlg.comboboxModeEliminateLanduse.currentText() == 'Largest Common Boundary':
            mode = 2
        elif self.dlg.comboboxModeEliminateLanduse.currentText() == 'Largest Area':
            mode = 0
        layerWithoutGaps = self.fillGaps(self.landuseTalsim,self.clippingEZG, mode)
        if self.landuseTalsim:
            QgsProject.instance().removeMapLayer(self.landuseTalsim)
        self.landuseTalsim = layerWithoutGaps
        self.landuseTalsim.setName("LanduseLayerEdited")
        QgsProject.instance().addMapLayer(self.landuseTalsim)
        self.log_to_qtalsim_tab(f"Filled gaps of layer {self.landuseTalsim.name()}.", Qgis.Info) 

    def createLanduseLayer(self):
        '''
            Creates the Talsim Landuse Layer that is used for intersecting.
                Dissolves the Talsim Landuse Layer.
        '''
        #Dissolve the layer using the talsim landuse parameters
        resultDissolve = processing.run("native:dissolve", {'INPUT':self.landuseTalsim,'FIELD': self.selected_landuse_parameters,'SEPARATE_DISJOINT':True,'OUTPUT':'TEMPORARY_OUTPUT'})
        dissolvedLayer = resultDissolve['OUTPUT']
        if self.landuseTalsim:
            QgsProject.instance().removeMapLayer(self.landuseTalsim)
        self.landuseTalsim = dissolvedLayer
        self.landuseTalsim.setName("Talsim Landuse")
        self.log_to_qtalsim_tab(f"Created Landuse Layer with Talsim Parameters: {self.landuseTalsim.name()}.", Qgis.Info) 
        QgsProject.instance().addMapLayer(self.landuseTalsim)

    def performIntersect(self):
        '''
            Performs intersect of the three input layers after processing them in the previous steps.
        '''
        self.log_to_qtalsim_tab(f"Starting the intersecting process of layers: {self.ezgLayer.name()}, {self.landuseTalsim.name()} and {self.soilTalsim.name()}.", Qgis.Info) 
        self.slopeField = self.dlg.comboboxSlopeField.currentText()
        try:
            #Create a copy of the catchment area layer to not edit the input layer
            ezgLayer1 = QgsVectorLayer(f"Polygon?crs={self.ezgLayer.crs().authid()}", "EZG", "memory")
            feats = [feat for feat in self.ezgLayer.getFeatures()]

            mem_layer_data = ezgLayer1.dataProvider()
            attr = self.ezgLayer.dataProvider().fields().toList()
            mem_layer_data.addAttributes(attr)
            ezgLayer1.updateFields()
            mem_layer_data.addFeatures(feats)

            self.ezgUniqueIdentifier = self.dlg.comboboxUICatchment.currentText()
        except Exception as e:
            self.log_to_qtalsim_tab(e, Qgis.Critical)
        #ezgFeatureID = str('SubBasinId') 

        '''
            Intersection
        '''
        try:
            intermediateResultIntersect = processing.run("native:intersection", {
                'INPUT': self.landuseTalsim,
                'OVERLAY': ezgLayer1,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            })['OUTPUT']

            
            intermediateIntersectSingleparts = processing.run("native:multiparttosingleparts", {
                'INPUT': intermediateResultIntersect,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            })['OUTPUT']
            
            intersectedLayer = processing.run("native:intersection", {
                'INPUT': intermediateIntersectSingleparts,
                'OVERLAY': self.soilTalsim,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            })['OUTPUT']
        except Exception as e:
            self.log_to_qtalsim_tab(e, Qgis.Critical)

        #Calculate and store area of every catchment area
        ezgAreas = {}
        for feature in ezgLayer1.getFeatures():
            ezgAreas[feature[self.ezgUniqueIdentifier]] = feature.geometry().area()

        #Dissolve Layer 1
        dissolve_list = []
        dissolve_list.append(self.ezgUniqueIdentifier)
        dissolve_list.append(self.slopeField)
        dissolve_list.extend(self.selected_landuse_parameters)
        dissolve_list.extend(self.soilFieldNames)
        resultDissolve = processing.run("native:dissolve", {'INPUT': intersectedLayer,'FIELD': dissolve_list,'SEPARATE_DISJOINT':True,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        intersectedDissolvedLayer = resultDissolve['OUTPUT']

        intersectedDissolvedLayer = self.fillGaps(intersectedDissolvedLayer, self.clippingEZG, 0)
        ezgDissolved = processing.run("native:dissolve", {'INPUT': self.ezgLayer,'FIELD': [],'SEPARATE_DISJOINT':True,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)['OUTPUT']
        intersectedDissolvedLayer = self.clipLayer(intersectedDissolvedLayer, ezgDissolved)
        intersectedDissolvedLayer, _ = self.editOverlappingFeatures(intersectedDissolvedLayer)
        #Split the intersected areas and create own layer for each catchment area
            # --> necessary for eliminating: deleted areas (e.g. area too small) should only take the attributes of features in the same catchment area
        resultSplit = processing.run("native:splitvectorlayer", {'INPUT': intersectedDissolvedLayer,'FIELD':self.ezgUniqueIdentifier,'PREFIX_FIELD':True,'FILE_TYPE':0,'OUTPUT':'TEMPORARY_OUTPUT'},feedback = self.feedback)
        outputDirSplit = resultSplit['OUTPUT']
        splitLayers = []
        for filename in os.listdir(outputDirSplit):
            ids_to_eliminate = []
            file_path = os.path.join(outputDirSplit, filename)
            tempLayersplit = QgsVectorLayer(file_path, filename, 'ogr')
            
            #'Multipart to singleparts' necessary because 'mergevectorlayer' does not allow Geometry Collections
            if tempLayersplit.isValid():
                tempLayersplit = processing.run("native:multiparttosingleparts", {
                    'INPUT': tempLayersplit,
                    'OUTPUT': 'memory:'
                },feedback=self.feedback)['OUTPUT']
            fieldAreaEFL = QgsField(self.fieldNameAreaEFL, QVariant.Double)
            tempLayersplit.dataProvider().addAttributes([fieldAreaEFL]) #create new field
            tempLayersplit.updateFields()
            #Select features to eliminate
            for feature in tempLayersplit.getFeatures():
                area = feature.geometry().area()
                ezg = feature[self.ezgUniqueIdentifier]
                try:
                    ezgArea = ezgAreas[ezg]
                    percentage = (area/ezgArea)*100
                except Exception as e:
                    self.log_to_qtalsim_tab(e, Qgis.Info)
                feature[self.fieldNameAreaEFL] = percentage
                if self.dlg.checkboxIntersectMinSizeArea and area < self.dlg.spinboxIntersectMinSizeArea.value(): # if area of feature < minimum accepted area specified by user
                    ids_to_eliminate.append(feature.id())
                if self.dlg.checkboxIntersectShareofArea and feature.id() not in ids_to_eliminate: #if the percentage-chechbox is chosen
                    if percentage < self.dlg.spinboxIntersectShareofArea.value():
                        ids_to_eliminate.append(feature.id()) #eliminate
            

            #Eliminate with mode specified by user
            tempLayersplit.selectByIds(ids_to_eliminate)
            mode = 0 
            if self.dlg.comboboxModeEliminateSoil.currentText() == 'Smallest Area':
                mode = 1
            elif self.dlg.comboboxModeEliminateSoil.currentText() == 'Largest Common Boundary':
                mode = 2
            elif self.dlg.comboboxModeEliminateSoil.currentText() == 'Largest Area':
                mode = 0
            tempLayerSplitEliminated = processing.run("qgis:eliminateselectedpolygons", {'INPUT':tempLayersplit,'MODE':mode,'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
            splitLayers.append(tempLayerSplitEliminated)

        #Merge all of the split layers
        resultMerge = processing.run("native:mergevectorlayers", {'LAYERS':splitLayers,'CRS':intersectedDissolvedLayer.crs(),'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)['OUTPUT']
        
        #Dissolve Layer 2
        resultDissolve = processing.run("native:dissolve", {'INPUT': resultMerge,'FIELD': dissolve_list,'SEPARATE_DISJOINT':True,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        self.finalLayer = resultDissolve['OUTPUT']
        self.finalLayer = self.fillGaps(self.finalLayer, self.clippingEZG, 0)
        self.finalLayer = self.clipLayer(self.finalLayer, ezgDissolved)
        self.finalLayer, _ = self.editOverlappingFeatures(self.finalLayer)
        self.finalLayer.setName("Talsim Layer")
        #Delete unwanted fields
        self.finalLayer.startEditing()
        dissolve_fields_indices = [self.finalLayer.fields().indexFromName(field) for field in dissolve_list]
        for i in range(self.finalLayer.fields().count() - 1, -1, -1):
            if i not in dissolve_fields_indices:
                self.finalLayer.deleteAttribute(i)
        self.finalLayer.commitChanges()
        QgsProject.instance().addMapLayer(self.finalLayer)
             
        #Log catchment areas where size of all Elementarflächen != size of catchment area
        sum_areas = {key: 0 for key in ezgAreas.keys()}
        for feature in self.finalLayer.getFeatures():
            area = feature.geometry().area()
            ezg = feature[self.ezgUniqueIdentifier]
            sum_areas[ezg] += area
        for key in ezgAreas:
            if key in sum_areas:
                if round(ezgAreas[key],0) != round(sum_areas[key],0):
                    self.log_to_qtalsim_tab(f'Catchment area with Unique-Identifier {key} has a different area {ezgAreas[key]} than the sum of all features in this catchment area {sum_areas[key]}.', Qgis.Warning)
        
        '''
            Create .EFL
        '''
        eflFieldList = []
        eflFieldList.append(self.ezgUniqueIdentifier) #ID of catchment area
        eflFieldList.append(self.IDSoil) #ID Soil
        eflFieldList.append(self.fieldLanduseID) #ID LNZ
        eflFieldList.append(self.slopeField) #Slope Field
        
        #self.eflLayer = QgsVectorLayer(f"Polygon?crs={self.finalLayer.crs().authid()}", 'eflLayer', 'memory') #create layer
        self.eflLayer = processing.run("native:dissolve", {'INPUT': self.finalLayer,'FIELD': eflFieldList, 'SEPARATE_DISJOINT':False,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)['OUTPUT']
        
        #Add Fields
        eflLayerDP = self.eflLayer.dataProvider()

        self.eflLayer.startEditing()
        #eflLayerDP.addAttributes(eflFields)
        eflLayerDP.addAttributes([QgsField(self.fieldNameAreaEFL, QVariant.Double)])
        self.eflLayer.commitChanges()
        self.eflLayer.updateFields()
        
        #Add data
        self.eflLayer.startEditing()
        for feature in self.eflLayer.getFeatures():
            area = feature.geometry().area()
            ezg = feature[self.ezgUniqueIdentifier]
            ezgArea = ezgAreas[ezg]
            percentage = (area/ezgArea)*100
            feature[self.fieldNameAreaEFL] = percentage
            self.eflLayer.updateFeature(feature)
        self.eflLayer.commitChanges()

        eflFieldList.append(self.fieldNameAreaEFL) #Area of Elementarfläche
        self.eflLayer.startEditing()
        dissolve_fields_indices = [self.eflLayer.fields().indexFromName(field) for field in eflFieldList]
        for i in range(self.eflLayer.fields().count() - 1, -1, -1):
            if i not in dissolve_fields_indices:
                self.eflLayer.deleteAttribute(i)
        self.eflLayer.commitChanges()

        #Rename the fieldnames  
        field_index = self.eflLayer.fields().indexFromName(self.IDSoil)
        self.eflLayer.startEditing()
        self.eflLayer.renameAttribute(field_index, self.hruSoilTypeId)
        field_index = self.eflLayer.fields().indexFromName(self.fieldLanduseID)
        self.eflLayer.renameAttribute(field_index, self.hruLandUseId)
        field_index = self.eflLayer.fields().indexFromName(self.ezgUniqueIdentifier)
        self.eflLayer.renameAttribute(field_index, self.subBasinUI)
        field_index = self.eflLayer.fields().indexFromName(self.slopeField)
        self.eflLayer.renameAttribute(field_index, self.slopeFieldName)
        self.eflLayer.commitChanges()
        self.eflLayer.setName("EFL")
        QgsProject.instance().addMapLayer(self.eflLayer) 

        '''
        #Delete:
        sums_by_subbasin = {}

        # Iterating over features in the layer
        for feature in self.eflLayer.getFeatures():
            subbasin_id = feature['SubBasinId']
            percentage_share = feature['PercentageShare']  

            # Add to the sum for the corresponding SubBasinId
            if subbasin_id in sums_by_subbasin:
                sums_by_subbasin[subbasin_id] += percentage_share
            else:
                sums_by_subbasin[subbasin_id] = percentage_share
        '''
        '''
            Create .LNZ
        '''
        resultDissolve = processing.run("native:dissolve", {'INPUT': self.finalLayer,'FIELD': self.selected_landuse_parameters,'SEPARATE_DISJOINT':False,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        self.landuseFinal = resultDissolve['OUTPUT']
        self.landuseFinal.startEditing()
        dissolve_fields_indices = [self.landuseFinal.fields().indexFromName(field) for field in self.selected_landuse_parameters]
        for i in range(self.landuseFinal.fields().count() - 1, -1, -1):
            if i not in dissolve_fields_indices:
                self.landuseFinal.deleteAttribute(i)
        self.landuseFinal.commitChanges()
        self.landuseFinal.setName("LNZ")

        field_index = self.landuseFinal.fields().indexFromName(self.fieldLanduseID)
        self.landuseFinal.startEditing()
        self.landuseFinal.renameAttribute(field_index, 'Id')
        self.landuseFinal.commitChanges()

        QgsProject.instance().addMapLayer(self.landuseFinal) 

        '''
            Create .BOA - SoilTexture
        '''
        try:
            self.soilFieldNames.remove(self.soilTypeThickness)
        except Exception as e:
            self.log_to_qtalsim_tab(e,Qgis.Critical)

        resultDissolve = processing.run("native:dissolve", {'INPUT': self.finalLayer,'FIELD': self.soilFieldNames,'SEPARATE_DISJOINT':False,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        self.soilTextureFinal = resultDissolve['OUTPUT']
        self.soilTextureFinal.startEditing()
        dissolve_fields_indices = [self.soilTextureFinal.fields().indexFromName(field) for field in self.soilFieldNames]
        for i in range(self.soilTextureFinal.fields().count() -1, -1, -1):
            if i not in dissolve_fields_indices:
                self.soilTextureFinal.deleteAttribute(i)
        self.soilTextureFinal.commitChanges()

        self.soilTextureFinal.setName("BOA")

        field_index = self.soilTextureFinal.fields().indexFromName(self.IDSoil)
        self.soilTextureFinal.startEditing()
        self.soilTextureFinal.renameAttribute(field_index, 'Id')
        field_index = self.soilTextureFinal.fields().indexFromName(self.nameSoil) 
        self.soilTextureFinal.renameAttribute(field_index, 'Name')
        self.soilTextureFinal.commitChanges()

        QgsProject.instance().addMapLayer(self.soilTextureFinal) 

        '''
            Create .BOD - SoilType
        '''
        soilTypeList = []
        soilTypeList.append(self.soilTypeThickness)
        soilTypeList.append(self.IDSoil)
        #if there are more SoilTypes --> add names of LayerThickness here
        resultDissolve = processing.run("native:dissolve", {'INPUT': self.finalLayer,'FIELD': soilTypeList,'SEPARATE_DISJOINT':False,'OUTPUT':'TEMPORARY_OUTPUT'}, feedback=self.feedback)
        self.soilTypeFinal = resultDissolve['OUTPUT']
        
        #Delete unwanted Ids
        self.soilTypeFinal.startEditing()
        dissolve_fields_indices = [self.soilTypeFinal.fields().indexFromName(field) for field in soilTypeList]
        for i in range(self.soilTypeFinal.fields().count() - 1, -1, -1):
            if i not in dissolve_fields_indices:
                self.soilTypeFinal.deleteAttribute(i)
        self.soilTypeFinal.commitChanges()
        #Add Fields Id and Name
        self.soilTypeFinal.startEditing()
        
        soilTypeDP = self.soilTypeFinal.dataProvider()
        soilTypeDP.addAttributes([QgsField("Id", QVariant.Int), QgsField("Name", QVariant.Int)])
        self.soilTypeFinal.commitChanges()
        self.soilTypeFinal.updateFields()

        self.soilTypeFinal.startEditing()
        for feature in self.soilTypeFinal.getFeatures():
            feature["Id"] = int(feature.id())
            self.soilTypeFinal.updateFeature(feature)
        self.soilTypeFinal.commitChanges()

        self.soilTypeFinal.setName("BOD")

        field_index = self.soilTypeFinal.fields().indexFromName(self.IDSoil)
        self.soilTypeFinal.startEditing()
        self.soilTypeFinal.renameAttribute(field_index, 'SoilTextureId1')
        self.soilTypeFinal.commitChanges()

        QgsProject.instance().addMapLayer(self.soilTypeFinal) 
        
    def selectOutputFolder(self):
        self.outputFolder = None
        self.outputFolder = QFileDialog.getExistingDirectory(self.dlg, "Select Folder","") #, options=options
        geopackage_name, ok = QInputDialog.getText(None, "GeoPackage Name", "Enter the name of the GeoPackage:")
        self.geopackage_path = os.path.join(self.outputFolder, f"{geopackage_name}.gpkg")
        if self.geopackage_path:
            self.dlg.outputPath.setText(self.geopackage_path)
        
    #DELETE:?       
    def toggleComboBoxVisibility(self, combobox, checkbox):
    # Toggle visibility based on checkbox state
        combobox.setVisible(checkbox.isChecked())

    #Eliminate
    def run(self):
        """Run method that performs all the real work"""
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = QTalsimDialog()

        
        layers = QgsProject.instance().layerTreeRoot().children() #fetch layers of Project
        self.feedback = self.CustomFeedback(self.log_to_qtalsim_tab)
        
        #EZG
        self.dlg.onEZG.clicked.connect(self.selectEZG)

        #Overlaps
        self.dlg.onOverlappingSoils.clicked.connect(self.checkOverlappingSoil)

        #Soil
        self.dlg.onSoil.clicked.connect(self.selectSoil)
        self.dlg.onConfirmSoilMapping.clicked.connect(self.confirmSoilMapping)
        self.dlg.onSoilTypeDelete.clicked.connect(self.deleteSoilTypes)
        self.dlg.onDeleteOverlappingSoilFeatures.clicked.connect(self.deleteOverlappingSoilFeatures)
        self.dlg.onCheckGapsSoil.clicked.connect(self.checkGapsSoil)
        self.dlg.comboboxModeEliminateSoil.clear()
        self.dlg.comboboxModeEliminateSoil.addItems(['Largest Area', 'Smallest Area','Largest Common Boundary']) 
        self.dlg.onFillGapsSoil.clicked.connect(self.fillGapsSoil)
        self.dlg.onCreateSoilLayer.setVisible(False)
        self.dlg.onCreateSoilLayer.clicked.connect(self.createSoilLayer)

        #Landuse
        self.dlg.onLanduseConfirm.setVisible(False)
        self.dlg.onLanduseLayer.clicked.connect(self.selectLanduse) 
        self.dlg.onLanduseField.clicked.connect(self.landuseAssigning)
        self.dlg.onLanduseTalsimCSV.clicked.connect(self.openLanduseTalsimCSV)
        self.dlg.onCheckOverlappingLanduse.clicked.connect(self.checkOverlappingLanduse)
        self.dlg.onLanduseStart.clicked.connect(self.fillLanduseTable)
        self.dlg.onLanduseConfirm.clicked.connect(self.confirmLanduseClassification)
        self.dlg.onDeleteOverlapsLanduse.clicked.connect(self.deleteOverlappingLanduseFeatures)
        self.dlg.onCheckGapsLanduse.clicked.connect(self.checkGapsLanduse)
        self.dlg.comboboxModeEliminateLanduse.clear()
        self.dlg.comboboxModeEliminateLanduse.addItems(['Largest Area', 'Smallest Area','Largest Common Boundary'])  
        self.dlg.onFillGapsLanduse.clicked.connect(self.fillGapsLanduse)
        self.dlg.onCreateLanduseLayer.setVisible(False)
        self.dlg.onCreateLanduseLayer.clicked.connect(self.createLanduseLayer)

        #Radio Buttons csv file
        self.dlg.radioButtonComma.toggled.connect(self.updateCsvDelimiter)
        self.dlg.radioButtonSemicolon.toggled.connect(self.updateCsvDelimiter)
        self.dlg.radioButtonTabulator.toggled.connect(self.updateCsvDelimiter)
        self.dlg.radioButtonSpace.toggled.connect(self.updateCsvDelimiter)
        self.dlg.radioButtonOtherDel.toggled.connect(self.updateCsvDelimiter)
       

        #Intersect
        self.dlg.onPerformIntersect.clicked.connect(self.performIntersect)
        self.dlg.comboboxEZGLayer.clear() #clear combobox EZG from previous runs
        self.dlg.comboboxEZGLayer.addItems([layer.name() for layer in layers])
        self.dlg.comboboxSoilLayer.clear() #clear combobox soil from previous runs
        self.dlg.comboboxSoilLayer.addItems([layer.name() for layer in layers])
        self.dlg.comboboxLanduseLayer.clear() #clear combobox Landuse from previous runs
        self.dlg.comboboxLanduseLayer.addItems([layer.name() for layer in layers])
        self.dlg.comboboxEliminateModes.clear()
        self.dlg.comboboxEliminateModes.addItems(['Largest Area', 'Smallest Area','Largest Common Boundary'])

        #Outputfile
        self.dlg.onOutputFolder.clicked.connect(self.selectOutputFolder)
        
        # show the dialog
        self.dlg.show()

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            def create_gpkg_save_layer(layer, gpkg_path, layer_name):
                params = {
                    'INPUT': layer,
                    'OUTPUT': gpkg_path,
                    'LAYER_NAME': layer_name,
                    'OVERWRITE': True,
                }
                processing.run("native:savefeatures", params)
                
            def add_layers_to_gpkg(layer, gpkg_path, layer_name):    
                params = {'INPUT': layer,
                        'OPTIONS': f'-update -nln {layer_name}',
                        'OUTPUT': gpkg_path}
                processing.run("gdal:convertformat", params)
            try:
                gpkg_path = self.geopackage_path
                if os.path.exists(gpkg_path): 
                    try:
                        os.remove(gpkg_path)
                    except Exception as e:
                        self.log_to_qtalsim_tab(f"Failed to delete existing GeoPackage: {e}",Qgis.Critical)
                create_gpkg_save_layer(self.finalLayer, gpkg_path, 'hru_total')
                add_layers_to_gpkg(self.eflLayer, gpkg_path,'hru') 
                add_layers_to_gpkg(self.landuseFinal, gpkg_path, 'landuse')
                add_layers_to_gpkg(self.soilTextureFinal, gpkg_path, 'soiltexture') 
                add_layers_to_gpkg(self.soilTypeFinal, gpkg_path, 'soiltype') 
                self.log_to_qtalsim_tab(f"File was saved to this folder: {self.outputFolder}", Qgis.Info)
            except Exception as e:
                self.log_to_qtalsim_tab(f"Error: {e}", Qgis.Critical)

